<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human MemoryNet: Interactive Learning Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .brain-icon {
            font-size: 4em;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            animation: fadeInUp 0.8s ease-out;
            backdrop-filter: blur(10px);
        }

        .section h2 {
            color: #5a67d8;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .memory-stages {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .stage {
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .stage:hover {
            transform: translateY(-10px);
            border-color: #5a67d8;
            box-shadow: 0 20px 40px rgba(90, 103, 216, 0.2);
        }

        .stage-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #5a67d8;
        }

        .stage h3 {
            color: #2d3748;
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .stage p {
            color: #4a5568;
            line-height: 1.6;
        }

        .interactive-demo {
            background: #2d3748;
            color: white;
            border-radius: 20px;
            padding: 40px;
            margin: 40px 0;
        }

        .demo-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .demo-button {
            background: linear-gradient(145deg, #5a67d8, #4c51bf);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(90, 103, 216, 0.3);
        }

        .demo-button:hover {
            background: linear-gradient(145deg, #4c51bf, #434190);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(90, 103, 216, 0.4);
        }

        .demo-button.active {
            background: linear-gradient(145deg, #38b2ac, #319795);
        }

        .memory-visualization {
            height: 400px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(10, 1fr);
            height: 100%;
            gap: 2px;
            padding: 10px;
        }

        .memory-cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .memory-cell:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .memory-cell.active {
            background: #38b2ac;
            box-shadow: 0 0 10px #38b2ac;
        }

        .memory-cell.episodic {
            background: #ed8936;
            box-shadow: 0 0 8px #ed8936;
        }

        .memory-cell.semantic {
            background: #9f7aea;
            box-shadow: 0 0 8px #9f7aea;
        }

        .memory-cell.fading {
            background: rgba(255, 255, 255, 0.3);
            animation: fadeOut 2s ease-out;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38b2ac, #4fd1c7);
            width: 0%;
            transition: width 2s ease;
        }

        .attention-visualization {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            align-items: center;
            margin: 30px 0;
        }

        .input-sequence, .memory-bank, .output-sequence {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .sequence-item {
            background: #5a67d8;
            color: white;
            padding: 10px;
            margin: 5px;
            border-radius: 8px;
            display: inline-block;
            min-width: 40px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .sequence-item:hover {
            transform: scale(1.05);
            background: #4c51bf;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .memory-type {
            background: white;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .memory-type:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .memory-type.episodic {
            border-top: 5px solid #ed8936;
        }

        .memory-type.semantic {
            border-top: 5px solid #9f7aea;
        }

        .info-panel {
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .info-panel h3 {
            color: #2d3748;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .info-panel ul {
            list-style: none;
            padding: 0;
        }

        .info-panel li {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #5a67d8;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }

        .info-panel li:hover {
            transform: translateX(5px);
        }

        .footer {
            text-align: center;
            color: white;
            padding: 40px 0;
            opacity: 0.8;
        }

        kbd {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 0.9em;
            margin: 0 2px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0.3;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5em;
            }
            
            .memory-stages {
                grid-template-columns: 1fr;
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .attention-visualization {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brain-icon">🧠</div>
            <h1>Human MemoryNet</h1>
            <p>An Interactive Journey Through Neural Network Architecture Inspired by Human Memory</p>
        </div>

        <div class="section">
            <h2>How Human Memory Works</h2>
            <div class="memory-stages">
                <div class="stage" onclick="showStageInfo('encoding')">
                    <div class="stage-icon">📥</div>
                    <h3>Encoding</h3>
                    <p>Information from our senses is transformed into neural representations that can be stored in memory. This process involves attention, pattern recognition, and association with existing knowledge.</p>
                </div>
                <div class="stage" onclick="showStageInfo('storage')">
                    <div class="stage-icon">🗄️</div>
                    <h3>Storage</h3>
                    <p>Encoded memories are consolidated and stored in neural networks. Memories can be strengthened through repetition and emotional significance, while unused memories may fade over time.</p>
                </div>
                <div class="stage" onclick="showStageInfo('retrieval')">
                    <div class="stage-icon">🔍</div>
                    <h3>Retrieval</h3>
                    <p>When we need to remember something, our brain searches through stored memories using cues and associations. This process can be influenced by context, emotion, and the strength of memory traces.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Interactive Memory Simulation</h2>
            <div class="interactive-demo">
                <div class="demo-controls">
                    <button class="demo-button" onclick="simulateEncoding()">🔄 Simulate Encoding</button>
                    <button class="demo-button" onclick="simulateRetrieval()">🎯 Simulate Retrieval</button>
                    <button class="demo-button" onclick="simulateForgetting()">📉 Simulate Forgetting</button>
                    <button class="demo-button" onclick="resetMemory()">🔄 Reset Memory</button>
                    <button class="demo-button" onclick="startMemoryGame()">🎮 Memory Game</button>
                </div>
                <div class="memory-visualization" id="memoryGrid">
                    <div class="memory-grid" id="memoryGridContainer"></div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="text-align: center; margin-top: 20px; opacity: 0.8;">
                    <span style="color: #38b2ac;">🟦 Active Memories</span> | 
                    <span style="color: #ed8936;">🟧 Episodic Memories</span> | 
                    <span style="color: #9f7aea;">🟪 Semantic Memories</span>
                </p>
                <p style="text-align: center; color: rgba(255,255,255,0.8); margin-top: 20px; font-size: 0.9em;">
                    💡 <strong>Keyboard Shortcuts:</strong> 
                    Press <kbd>1</kbd> Encoding | <kbd>2</kbd> Retrieval | <kbd>3</kbd> Forgetting | <kbd>4</kbd> Reset | <kbd>A</kbd> Attention | <kbd>Space</kbd> Auto-demo
                </p>
            </div>
        </div>

        <div class="section">
            <h2>Memory Types Comparison</h2>
            <div class="comparison-grid">
                <div class="memory-type episodic">
                    <h3>📅 Episodic Memory</h3>
                    <div class="info-panel">
                        <ul>
                            <li><strong>What:</strong> Personal experiences and events</li>
                            <li><strong>When:</strong> Time and place specific</li>
                            <li><strong>Examples:</strong> Your first day at school, last vacation</li>
                            <li><strong>Characteristics:</strong> Contextual, emotional, autobiographical</li>
                        </ul>
                    </div>
                </div>
                <div class="memory-type semantic">
                    <h3>📚 Semantic Memory</h3>
                    <div class="info-panel">
                        <ul>
                            <li><strong>What:</strong> Facts and general knowledge</li>
                            <li><strong>When:</strong> Timeless information</li>
                            <li><strong>Examples:</strong> Paris is the capital of France, 2+2=4</li>
                            <li><strong>Characteristics:</strong> Abstract, conceptual, universal</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Attention Mechanism Visualization</h2>
            <div class="attention-visualization">
                <div class="input-sequence">
                    <h3>Input Query</h3>
                    <div id="inputSequence">
                        <div class="sequence-item">🔍</div>
                        <div class="sequence-item">Query</div>
                    </div>
                </div>
                <div class="memory-bank">
                    <h3>Memory Bank</h3>
                    <div id="memoryBank">
                        <div class="sequence-item">📅 Episode 1</div>
                        <div class="sequence-item">📚 Fact A</div>
                        <div class="sequence-item">📅 Episode 2</div>
                        <div class="sequence-item">📚 Fact B</div>
                        <div class="sequence-item">📅 Episode 3</div>
                    </div>
                </div>
                <div class="output-sequence">
                    <h3>Retrieved Memory</h3>
                    <div id="outputSequence">
                        <div class="sequence-item">💭</div>
                        <div class="sequence-item">Result</div>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="demo-button" onclick="simulateAttention()">⚡ Simulate Attention</button>
            </div>
        </div>

        <div class="section">
            <h2>Human Memory Phenomena</h2>
            <div class="info-panel">
                <h3>Key Memory Characteristics Modeled</h3>
                <ul>
                    <li>🔄 <strong>Consolidation:</strong> Memories strengthen over time through repetition and importance</li>
                    <li>📉 <strong>Forgetting Curve:</strong> Unused memories fade exponentially over time</li>
                    <li>🎯 <strong>Selective Attention:</strong> We focus on relevant memories while ignoring others</li>
                    <li>🌟 <strong>Emotional Enhancement:</strong> Emotional memories are stronger and more persistent</li>
                    <li>🔗 <strong>Associative Recall:</strong> Memories are linked and can trigger each other</li>
                    <li>📍 <strong>Context Dependency:</strong> Environmental cues help in memory retrieval</li>
                </ul>
            </div>
        </div>

        <div class="section" id="performanceSection">
            <h2>Live Performance Metrics</h2>
            <div class="info-panel">
                <div id="metricsDisplay"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="demo-button" onclick="updateMetrics()">🔄 Refresh Metrics</button>
                    <button class="demo-button" onclick="toggleAutoDemo()" style="margin-left: 10px;">▶️ Auto Demo</button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>🧠 Human MemoryNet - Bridging Neuroscience and AI 🤖</p>
            <p>Explore, Learn, and Understand How Memory Works</p>
        </div>
    </div>

    <script>
        // Global variables
        let memoryGrid = [];
        let isGameActive = false;
        let autoDemoInterval = null;
        let gamePattern = [];
        let userPattern = [];
        
        // Initialize memory grid
        function initializeMemoryGrid() {
            const container = document.getElementById('memoryGridContainer');
            if (!container) return;
            
            container.innerHTML = '';
            memoryGrid = [];
            
            for (let i = 0; i < 200; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                cell.dataset.index = i;
                cell.addEventListener('click', function() {
                    toggleMemoryCell(i);
                });
                container.appendChild(cell);
                memoryGrid.push(cell);
            }
        }

        // Toggle memory cell state
        function toggleMemoryCell(index) {
            if (index < 0 || index >= memoryGrid.length) return;
            
            const cell = memoryGrid[index];
            if (!cell) return;
            
            if (cell.classList.contains('active')) {
                cell.className = 'memory-cell';
            } else {
                cell.className = 'memory-cell active';
            }
        }

        // Simulate memory encoding
        function simulateEncoding() {
            if (memoryGrid.length === 0) {
                alert('Memory grid not initialized. Please refresh the page.');
                return;
            }
            
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = '0%';
            }
            
            // Reset all cells first
            memoryGrid.forEach(cell => {
                cell.className = 'memory-cell';
            });
            
            // Randomly activate cells to simulate encoding
            const numCells = Math.floor(Math.random() * 25) + 15;
            const indices = new Set();
            
            while (indices.size < numCells) {
                indices.add(Math.floor(Math.random() * 200));
            }
            
            const indicesArray = Array.from(indices);
            
            indicesArray.forEach((index, i) => {
                setTimeout(() => {
                    const cell = memoryGrid[index];
                    if (cell) {
                        const memoryType = Math.random() > 0.5 ? 'episodic' : 'semantic';
                        cell.classList.add('active');
                        setTimeout(() => {
                            cell.classList.remove('active');
                        }, 600);
                    }
                }, i * 800);
            });
            
            // Start recall phase
            setTimeout(() => {
                alert('Now click the cells in the same order you saw them light up!');
                
                const gameClickHandler = function() {
                    if (!isGameActive) return;
                    
                    const index = parseInt(this.dataset.index);
                    userPattern.push(index);
                    this.classList.add('active');
                    
                    if (userPattern.length === gamePattern.length) {
                        isGameActive = false;
                        
                        const correct = userPattern.every((val, i) => val === gamePattern[i]);
                        
                        setTimeout(() => {
                            if (correct) {
                                alert('🎉 Perfect! You have excellent memory!\n\nYour brain successfully encoded, stored, and retrieved the sequence!');
                            } else {
                                alert(`🤔 Close, but not quite right. Memory is tricky!\n\nCorrect pattern: ${gamePattern.join(', ')}\nYour pattern: ${userPattern.join(', ')}\n\nTry again to improve your memory skills!`);
                            }
                            resetMemory();
                            
                            // Remove event listeners
                            memoryGrid.forEach(cell => {
                                cell.removeEventListener('click', gameClickHandler);
                            });
                        }, 1000);
                    }
                };
                
                // Add event listeners for game
                memoryGrid.forEach(cell => {
                    cell.addEventListener('click', gameClickHandler);
                });
                
            }, gamePattern.length * 800 + 1000);
        }

        // Performance metrics
        function updateMetrics() {
            const metrics = {
                'Memory Utilization': Math.random() * 0.3 + 0.6,
                'Attention Coherence': Math.random() * 0.2 + 0.75,
                'Retrieval Accuracy': Math.random() * 0.15 + 0.8,
                'Consolidation Rate': Math.random() * 0.1 + 0.85
            };
            
            const display = document.getElementById('metricsDisplay');
            if (display) {
                display.innerHTML = Object.entries(metrics).map(([name, value]) => `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0; padding: 10px; background: white; border-radius: 8px; transition: all 0.3s ease;">
                        <span><strong>${name}:</strong></span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 200px; height: 10px; background: #e2e8f0; border-radius: 5px; overflow: hidden;">
                                <div style="width: ${value * 100}%; height: 100%; background: linear-gradient(90deg, #38b2ac, #4fd1c7); transition: width 1s ease;"></div>
                            </div>
                            <span style="min-width: 50px; text-align: right; font-weight: 600; color: #2d3748;">${(value * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                `).join('');
            }
        }

        // Auto demo functionality
        function toggleAutoDemo() {
            if (autoDemoInterval) {
                clearInterval(autoDemoInterval);
                autoDemoInterval = null;
                
                const button = event.target;
                button.textContent = '▶️ Auto Demo';
                button.style.background = 'linear-gradient(145deg, #5a67d8, #4c51bf)';
            } else {
                const demos = [simulateEncoding, simulateRetrieval, simulateForgetting];
                let currentDemo = 0;
                
                demos[currentDemo]();
                currentDemo = (currentDemo + 1) % demos.length;
                
                autoDemoInterval = setInterval(() => {
                    demos[currentDemo]();
                    currentDemo = (currentDemo + 1) % demos.length;
                }, 5000);
                
                const button = event.target;
                button.textContent = '⏹️ Stop Auto';
                button.style.background = 'linear-gradient(145deg, #e53e3e, #c53030)';
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            switch(event.key) {
                case '1':
                    event.preventDefault();
                    simulateEncoding();
                    break;
                case '2':
                    event.preventDefault();
                    simulateRetrieval();
                    break;
                case '3':
                    event.preventDefault();
                    simulateForgetting();
                    break;
                case '4':
                    event.preventDefault();
                    resetMemory();
                    break;
                case 'a':
                case 'A':
                    event.preventDefault();
                    simulateAttention();
                    break;
                case ' ':
                    event.preventDefault();
                    toggleAutoDemo();
                    break;
            }
        });

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Initialize memory grid
                initializeMemoryGrid();
                
                // Initialize metrics
                updateMetrics();
                
                // Show welcome message
                setTimeout(() => {
                    if (confirm('🧠 Welcome to Human MemoryNet!\n\nThis interactive visualization demonstrates how neural networks can mimic human memory processes.\n\nWould you like to see a quick demo?\n\nClick OK for auto-demo, or Cancel to explore manually.')) {
                        toggleAutoDemo();
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Initialization error:', error);
                alert('There was an error loading the visualization. Please refresh the page.');
            }
        });

        // Global error handler
        window.addEventListener('error', function(event) {
            console.error('Script error caught:', event.error);
            return true; // Prevent default error handling
        });
    </script>
</body>
</html>className = `memory-cell ${memoryType}`;
                        
                        // Update progress
                        if (progressFill) {
                            progressFill.style.width = `${((i + 1) / numCells) * 100}%`;
                        }
                    }
                }, i * 80);
            });
        }

        // Simulate memory retrieval
        function simulateRetrieval() {
            const activeCells = memoryGrid.filter(cell => 
                cell.classList.contains('episodic') || cell.classList.contains('semantic')
            );
            
            if (activeCells.length === 0) {
                alert('No memories to retrieve! Try encoding some memories first by clicking "Simulate Encoding".');
                return;
            }
            
            // Clear any previous active states
            memoryGrid.forEach(cell => {
                cell.classList.remove('active');
            });
            
            // Randomly select cells for retrieval
            const retrievalCount = Math.min(8, activeCells.length);
            const selectedCells = [];
            
            while (selectedCells.length < retrievalCount && selectedCells.length < activeCells.length) {
                const randomCell = activeCells[Math.floor(Math.random() * activeCells.length)];
                if (!selectedCells.includes(randomCell)) {
                    selectedCells.push(randomCell);
                }
            }
            
            // Animate retrieval
            selectedCells.forEach((cell, i) => {
                setTimeout(() => {
                    cell.classList.add('active');
                    setTimeout(() => {
                        cell.classList.remove('active');
                    }, 1200);
                }, i * 150);
            });
        }

        // Simulate forgetting
        function simulateForgetting() {
            const activeCells = memoryGrid.filter(cell => 
                cell.classList.contains('episodic') || cell.classList.contains('semantic')
            );
            
            if (activeCells.length === 0) {
                alert('No memories to forget! Try encoding some memories first.');
                return;
            }
            
            const episodicCells = activeCells.filter(cell => cell.classList.contains('episodic'));
            const semanticCells = activeCells.filter(cell => cell.classList.contains('semantic'));
            
            const episodicForgetCount = Math.floor(episodicCells.length * 0.4);
            const semanticForgetCount = Math.floor(semanticCells.length * 0.2);
            
            // Animate forgetting for episodic memories
            for (let i = 0; i < episodicForgetCount; i++) {
                const randomCell = episodicCells[Math.floor(Math.random() * episodicCells.length)];
                setTimeout(() => {
                    if (randomCell) {
                        randomCell.classList.add('fading');
                        setTimeout(() => {
                            randomCell.className = 'memory-cell';
                        }, 2000);
                    }
                }, i * 200);
            }
            
            // Animate forgetting for semantic memories
            for (let i = 0; i < semanticForgetCount; i++) {
                const randomCell = semanticCells[Math.floor(Math.random() * semanticCells.length)];
                setTimeout(() => {
                    if (randomCell) {
                        randomCell.classList.add('fading');
                        setTimeout(() => {
                            randomCell.className = 'memory-cell';
                        }, 2000);
                    }
                }, (episodicForgetCount * 200) + (i * 300));
            }
        }

        // Reset memory grid
        function resetMemory() {
            const progressFill = document.getElementById('progressFill');
            
            if (memoryGrid.length > 0) {
                memoryGrid.forEach(cell => {
                    cell.className = 'memory-cell';
                });
            }
            
            if (progressFill) {
                progressFill.style.width = '0%';
            }
        }

        // Simulate attention mechanism
        function simulateAttention() {
            const memoryBankItems = document.querySelectorAll('#memoryBank .sequence-item');
            const outputSequence = document.getElementById('outputSequence');
            
            if (!memoryBankItems.length || !outputSequence) return;
            
            // Reset all items
            memoryBankItems.forEach(item => {
                item.style.background = '#5a67d8';
                item.style.transform = 'scale(1)';
                item.style.boxShadow = '';
            });
            
            outputSequence.innerHTML = `
                <div class="sequence-item">💭</div>
                <div class="sequence-item">Processing...</div>
            `;
            
            let maxAttentionItem = null;
            let maxAttention = 0;
            
            memoryBankItems.forEach((item, index) => {
                setTimeout(() => {
                    const attention = Math.random();
                    const opacity = 0.4 + (attention * 0.6);
                    const scale = 1 + (attention * 0.4);
                    
                    const color = `rgba(56, 178, 172, ${opacity})`;
                    item.style.background = color;
                    item.style.transform = `scale(${scale})`;
                    
                    if (attention > maxAttention) {
                        maxAttention = attention;
                        maxAttentionItem = item;
                    }
                    
                    if (index === memoryBankItems.length - 1) {
                        setTimeout(() => {
                            if (maxAttentionItem) {
                                maxAttentionItem.style.background = '#38b2ac';
                                maxAttentionItem.style.boxShadow = '0 0 20px #38b2ac';
                                maxAttentionItem.style.transform = 'scale(1.3)';
                                
                                setTimeout(() => {
                                    outputSequence.innerHTML = `
                                        <div class="sequence-item" style="background: #38b2ac;">💭</div>
                                        <div class="sequence-item" style="background: #38b2ac;">${maxAttentionItem.textContent}</div>
                                    `;
                                }, 300);
                            }
                        }, 500);
                    }
                }, index * 100);
            });
        }

        // Show stage information
        function showStageInfo(stage) {
            const info = {
                encoding: "🔄 Encoding Stage\n\nIn our neural network, encoding transforms input sequences into high-dimensional vector representations using embedding layers and transformer encoders. This mimics how the brain converts sensory information into neural patterns.\n\nTechnical Details:\n• Embedding Layer: Maps tokens to 128-dimensional vectors\n• Positional Encoding: Adds sequence position information\n• Transformer Encoder: Creates contextual representations\n• Temporal Integration: Incorporates time-based features",
                storage: "🗄️ Storage Stage\n\nThe external memory module stores encoded representations in a learnable matrix with 1000 memory slots. Each memory has associated metadata including usage frequency, age, and emotional strength.\n\nTechnical Details:\n• External Memory Matrix: 1000 × 128 dimensional storage\n• Memory Gating: Controls what gets stored\n• Consolidation: Strengthens memories over time\n• Forgetting Mechanism: Implements realistic decay",
                retrieval: "🔍 Retrieval Stage\n\nMulti-head attention mechanisms select relevant memories based on the current query. This process simulates how humans recall information through associative patterns and contextual cues.\n\nTechnical Details:\n• Multi-Head Attention: 8 attention heads\n• Query-Key-Value: Standard attention mechanism\n• Context Integration: Combines input with memories\n• Attention Visualization: Shows memory activation patterns"
            };
            
            if (info[stage]) {
                alert(info[stage]);
            }
        }

        // Memory game
        function startMemoryGame() {
            if (isGameActive) {
                alert('Game already in progress!');
                return;
            }
            
            isGameActive = true;
            resetMemory();
            
            const patternLength = 5;
            gamePattern = [];
            userPattern = [];
            
            while (gamePattern.length < patternLength) {
                const index = Math.floor(Math.random() * 200);
                if (!gamePattern.includes(index)) {
                    gamePattern.push(index);
                }
            }
            
            alert('🎮 Memory Game Starting!\n\nWatch carefully as cells light up in sequence, then click them back in the same order!');
            
            // Display pattern
            gamePattern.forEach((index, i) => {
                setTimeout(() => {
                    const cell = memoryGrid[index];
                    if (cell) {
                        cell.
