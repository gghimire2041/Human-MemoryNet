<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human MemoryNet: Interactive Learning Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .brain-icon {
            font-size: 4em;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            animation: fadeInUp 0.8s ease-out;
            backdrop-filter: blur(10px);
        }

        .section h2 {
            color: #5a67d8;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .memory-stages {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .stage {
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .stage::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .stage:hover::before {
            left: 100%;
        }

        .stage:hover {
            transform: translateY(-10px);
            border-color: #5a67d8;
            box-shadow: 0 20px 40px rgba(90, 103, 216, 0.2);
        }

        .stage-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #5a67d8;
        }

        .stage h3 {
            color: #2d3748;
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .stage p {
            color: #4a5568;
            line-height: 1.6;
        }

        .interactive-demo {
            background: #2d3748;
            color: white;
            border-radius: 20px;
            padding: 40px;
            margin: 40px 0;
        }

        .demo-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .demo-button {
            background: linear-gradient(145deg, #5a67d8, #4c51bf);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(90, 103, 216, 0.3);
        }

        .demo-button:hover {
            background: linear-gradient(145deg, #4c51bf, #434190);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(90, 103, 216, 0.4);
        }

        .demo-button.active {
            background: linear-gradient(145deg, #38b2ac, #319795);
        }

        .memory-visualization {
            height: 400px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(10, 1fr);
            height: 100%;
            gap: 2px;
            padding: 10px;
        }

        .memory-cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .memory-cell.active {
            background: #38b2ac;
            box-shadow: 0 0 10px #38b2ac;
        }

        .memory-cell.episodic {
            background: #ed8936;
            box-shadow: 0 0 8px #ed8936;
        }

        .memory-cell.semantic {
            background: #9f7aea;
            box-shadow: 0 0 8px #9f7aea;
        }

        .memory-cell.fading {
            background: rgba(255, 255, 255, 0.3);
            animation: fadeOut 2s ease-out;
        }

        .attention-visualization {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            align-items: center;
            margin: 30px 0;
        }

        .input-sequence, .memory-bank, .output-sequence {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .sequence-item {
            background: #5a67d8;
            color: white;
            padding: 10px;
            margin: 5px;
            border-radius: 8px;
            display: inline-block;
            min-width: 40px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .sequence-item:hover {
            transform: scale(1.1);
            background: #4c51bf;
        }

        .attention-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #38b2ac, #4fd1c7);
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 0 10px #38b2ac;
        }

        .attention-line.active {
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        .info-panel {
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .info-panel h3 {
            color: #2d3748;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .info-panel ul {
            list-style: none;
            padding: 0;
        }

        .info-panel li {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #5a67d8;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }

        .info-panel li:hover {
            transform: translateX(5px);
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .memory-type {
            background: white;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .memory-type:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .memory-type.episodic {
            border-top: 5px solid #ed8936;
        }

        .memory-type.semantic {
            border-top: 5px solid #9f7aea;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38b2ac, #4fd1c7);
            width: 0%;
            transition: width 2s ease;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0.3;
            }
        }

        .footer {
            text-align: center;
            color: white;
            padding: 40px 0;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5em;
            }
            
            .memory-stages {
                grid-template-columns: 1fr;
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .attention-visualization {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brain-icon">🧠</div>
            <h1>Human MemoryNet</h1>
            <p>An Interactive Journey Through Neural Network Architecture Inspired by Human Memory</p>
        </div>

        <div class="section">
            <h2>How Human Memory Works</h2>
            <div class="memory-stages">
                <div class="stage" onclick="highlightStage('encoding')">
                    <div class="stage-icon">📥</div>
                    <h3>Encoding</h3>
                    <p>Information from our senses is transformed into neural representations that can be stored in memory. This process involves attention, pattern recognition, and association with existing knowledge.</p>
                </div>
                <div class="stage" onclick="highlightStage('storage')">
                    <div class="stage-icon">🗄️</div>
                    <h3>Storage</h3>
                    <p>Encoded memories are consolidated and stored in neural networks. Memories can be strengthened through repetition and emotional significance, while unused memories may fade over time.</p>
                </div>
                <div class="stage" onclick="highlightStage('retrieval')">
                    <div class="stage-icon">🔍</div>
                    <h3>Retrieval</h3>
                    <p>When we need to remember something, our brain searches through stored memories using cues and associations. This process can be influenced by context, emotion, and the strength of memory traces.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Interactive Memory Simulation</h2>
            <div class="interactive-demo">
                <div class="demo-controls">
                    <button class="demo-button" onclick="simulateEncoding()">🔄 Simulate Encoding</button>
                    <button class="demo-button" onclick="simulateRetrieval()">🎯 Simulate Retrieval</button>
                    <button class="demo-button" onclick="simulateForgetting()">📉 Simulate Forgetting</button>
                    <button class="demo-button" onclick="resetMemory()">🔄 Reset Memory</button>
                </div>
                <div class="memory-visualization" id="memoryGrid">
                    <div class="memory-grid" id="memoryGridContainer"></div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="text-align: center; margin-top: 20px; opacity: 0.8;">
                    <span style="color: #38b2ac;">🟦 Active Memories</span> | 
                    <span style="color: #ed8936;">🟧 Episodic Memories</span> | 
                    <span style="color: #9f7aea;">🟪 Semantic Memories</span>
                </p>
            </div>
        </div>

        <div class="section">
            <h2>Memory Types Comparison</h2>
            <div class="comparison-grid">
                <div class="memory-type episodic">
                    <h3>📅 Episodic Memory</h3>
                    <div class="info-panel">
                        <ul>
                            <li><strong>What:</strong> Personal experiences and events</li>
                            <li><strong>When:</strong> Time and place specific</li>
                            <li><strong>Examples:</strong> Your first day at school, last vacation</li>
                            <li><strong>Characteristics:</strong> Contextual, emotional, autobiographical</li>
                        </ul>
                    </div>
                </div>
                <div class="memory-type semantic">
                    <h3>📚 Semantic Memory</h3>
                    <div class="info-panel">
                        <ul>
                            <li><strong>What:</strong> Facts and general knowledge</li>
                            <li><strong>When:</strong> Timeless information</li>
                            <li><strong>Examples:</strong> Paris is the capital of France, 2+2=4</li>
                            <li><strong>Characteristics:</strong> Abstract, conceptual, universal</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Attention Mechanism Visualization</h2>
            <div class="attention-visualization">
                <div class="input-sequence">
                    <h3>Input Query</h3>
                    <div id="inputSequence">
                        <div class="sequence-item">🔍</div>
                        <div class="sequence-item">Query</div>
                    </div>
                </div>
                <div class="memory-bank">
                    <h3>Memory Bank</h3>
                    <div id="memoryBank">
                        <div class="sequence-item">📅 Episode 1</div>
                        <div class="sequence-item">📚 Fact A</div>
                        <div class="sequence-item">📅 Episode 2</div>
                        <div class="sequence-item">📚 Fact B</div>
                        <div class="sequence-item">📅 Episode 3</div>
                    </div>
                </div>
                <div class="output-sequence">
                    <h3>Retrieved Memory</h3>
                    <div id="outputSequence">
                        <div class="sequence-item">💭</div>
                        <div class="sequence-item">Result</div>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="demo-button" onclick="simulateAttention()">⚡ Simulate Attention</button>
            </div>
        </div>

        <div class="section">
            <h2>Human Memory Phenomena</h2>
            <div class="info-panel">
                <h3>Key Memory Characteristics Modeled</h3>
                <ul>
                    <li>🔄 <strong>Consolidation:</strong> Memories strengthen over time through repetition and importance</li>
                    <li>📉 <strong>Forgetting Curve:</strong> Unused memories fade exponentially over time</li>
                    <li>🎯 <strong>Selective Attention:</strong> We focus on relevant memories while ignoring others</li>
                    <li>🌟 <strong>Emotional Enhancement:</strong> Emotional memories are stronger and more persistent</li>
                    <li>🔗 <strong>Associative Recall:</strong> Memories are linked and can trigger each other</li>
                    <li>📍 <strong>Context Dependency:</strong> Environmental cues help in memory retrieval</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Technical Architecture</h2>
            <div class="info-panel">
                <h3>Neural Network Components</h3>
                <ul>
                    <li>🔤 <strong>Embedding Layer:</strong> Converts input tokens to vector representations</li>
                    <li>🏗️ <strong>Transformer Encoder:</strong> Processes sequences and builds representations</li>
                    <li>🗄️ <strong>External Memory Matrix:</strong> Stores long-term memories (1000 slots)</li>
                    <li>👁️ <strong>Multi-Head Attention:</strong> Selectively retrieves relevant memories</li>
                    <li>⏰ <strong>Temporal Processing:</strong> Incorporates time-based context</li>
                    <li>🧮 <strong>Output Layers:</strong> Classification, prediction, and reconstruction</li>
                </ul>
            </div>
        </div>

        <div class="footer">
            <p>🧠 Human MemoryNet - Bridging Neuroscience and AI 🤖</p>
            <p>Explore, Learn, and Understand How Memory Works</p>
        </div>
    </div>

    <script>
        // Global variables
        let memoryGrid = [];
        let isGameActive = false;
        
        // Initialize memory grid
        function initializeMemoryGrid() {
            const container = document.getElementById('memoryGridContainer');
            if (!container) {
                console.error('Memory grid container not found');
                return;
            }
            
            container.innerHTML = '';
            memoryGrid = [];
            
            for (let i = 0; i < 200; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                cell.dataset.index = i;
                cell.addEventListener('click', function(e) {
                    e.preventDefault();
                    toggleMemoryCell(i);
                });
                container.appendChild(cell);
                memoryGrid.push(cell);
            }
            console.log('Memory grid initialized with', memoryGrid.length, 'cells');
        }

        // Toggle memory cell state
        function toggleMemoryCell(index) {
            const cell = document.querySelector(`[data-index="${index}"]`);
            if (cell.classList.contains('active')) {
                cell.className = 'memory-cell';
            } else {
                cell.className = 'memory-cell active';
            }
        }

        // Simulate memory encoding
        function simulateEncoding() {
            const cells = document.querySelectorAll('.memory-cell');
            const progressFill = document.getElementById('progressFill');
            
            // Reset progress
            progressFill.style.width = '0%';
        }

        // Simulate attention mechanism
        function simulateAttention() {
            const memoryBankItems = document.querySelectorAll('#memoryBank .sequence-item');
            const outputSequence = document.getElementById('outputSequence');
            
            // Reset all items
            memoryBankItems.forEach(item => {
                item.style.background = '#5a67d8';
                item.style.transform = 'scale(1)';
            });
            
            // Simulate attention weights
            memoryBankItems.forEach((item, index) => {
                setTimeout(() => {
                    const attention = Math.random();
                    const opacity = 0.3 + (attention * 0.7);
                    const scale = 1 + (attention * 0.3);
                    
                    item.style.background = `rgba(56, 178, 172, ${opacity})`;
                    item.style.transform = `scale(${scale})`;
                    
                    // Highlight most attended item
                    if (attention > 0.7) {
                        item.style.background = '#38b2ac';
                        item.style.boxShadow = '0 0 20px #38b2ac';
                        
                        // Update output
                        setTimeout(() => {
                            outputSequence.innerHTML = `
                                <div class="sequence-item" style="background: #38b2ac;">💭</div>
                                <div class="sequence-item" style="background: #38b2ac;">${item.textContent}</div>
                            `;
                        }, 500);
                    }
                }, index * 200);
            });
        }

        // Highlight memory stage
        function highlightStage(stage) {
            console.log('Highlighting stage:', stage);
            
            // Remove previous highlights
            document.querySelectorAll('.stage').forEach(s => {
                s.style.border = '2px solid transparent';
                s.style.boxShadow = '';
            });
            
            // Find the clicked stage
            const clickedStage = event.target.closest('.stage');
            if (clickedStage) {
                clickedStage.style.border = '2px solid #38b2ac';
                clickedStage.style.boxShadow = '0 0 30px rgba(56, 178, 172, 0.3)';
            }
            
            // Show stage-specific information
            showStageInfo(stage);
        }

        // Show stage-specific information
        function showStageInfo(stage) {
            const info = {
                encoding: {
                    title: "🔄 Encoding Stage",
                    description: "In our neural network, encoding transforms input sequences into high-dimensional vector representations using embedding layers and transformer encoders. This mimics how the brain converts sensory information into neural patterns.",
                    technical: "Technical Details:\n• Embedding Layer: Maps tokens to 128-dimensional vectors\n• Positional Encoding: Adds sequence position information\n• Transformer Encoder: Creates contextual representations\n• Temporal Integration: Incorporates time-based features"
                },
                storage: {
                    title: "🗄️ Storage Stage", 
                    description: "The external memory module stores encoded representations in a learnable matrix with 1000 memory slots. Each memory has associated metadata including usage frequency, age, and emotional strength.",
                    technical: "Technical Details:\n• External Memory Matrix: 1000 × 128 dimensional storage\n• Memory Gating: Controls what gets stored\n• Consolidation: Strengthens memories over time\n• Forgetting Mechanism: Implements realistic decay"
                },
                retrieval: {
                    title: "🔍 Retrieval Stage",
                    description: "Multi-head attention mechanisms select relevant memories based on the current query. This process simulates how humans recall information through associative patterns and contextual cues.",
                    technical: "Technical Details:\n• Multi-Head Attention: 8 attention heads\n• Query-Key-Value: Standard attention mechanism\n• Context Integration: Combines input with memories\n• Attention Visualization: Shows memory activation patterns"
                }
            };
            
            const selectedInfo = info[stage];
            if (selectedInfo) {
                alert(`${selectedInfo.title}\n\n${selectedInfo.description}\n\n${selectedInfo.technical}`);
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Page loaded, initializing...');
            
            // Initialize memory grid
            initializeMemoryGrid();
            
            // Set initial section states for animation
            const sections = document.querySelectorAll('.section');
            sections.forEach((section, index) => {
                section.style.opacity = '0';
                section.style.transform = 'translateY(50px)';
                section.style.transition = 'all 0.8s ease';
                
                // Stagger animations
                setTimeout(() => {
                    section.style.opacity = '1';
                    section.style.transform = 'translateY(0)';
                }, 200 * index);
            });
            
            // Initialize performance display after a delay
            setTimeout(() => {
                createPerformanceDisplay();
                updateMetricsDisplay();
            }, 2000);
            
            console.log('Initialization complete');
        });

        // Auto-demo functionality
        let autoDemoInterval = null;
        
        function startAutoDemo() {
            if (autoDemoInterval) {
                console.log('Auto demo already running');
                return;
            }
            
            console.log('Starting auto demo...');
            const demos = [simulateEncoding, simulateRetrieval, simulateForgetting];
            let currentDemo = 0;
            
            // Run first demo immediately
            demos[currentDemo]();
            currentDemo = (currentDemo + 1) % demos.length;
            
            autoDemoInterval = setInterval(() => {
                demos[currentDemo]();
                currentDemo = (currentDemo + 1) % demos.length;
            }, 5000);
        }
        
        function stopAutoDemo() {
            if (autoDemoInterval) {
                console.log('Stopping auto demo');
                clearInterval(autoDemoInterval);
                autoDemoInterval = null;
            }
        }

        // Add keyboard shortcuts with error handling
        document.addEventListener('keydown', function(event) {
            try {
                switch(event.key) {
                    case '1':
                        event.preventDefault();
                        simulateEncoding();
                        break;
                    case '2':
                        event.preventDefault();
                        simulateRetrieval();
                        break;
                    case '3':
                        event.preventDefault();
                        simulateForgetting();
                        break;
                    case '4':
                        event.preventDefault();
                        resetMemory();
                        break;
                    case 'a':
                    case 'A':
                        event.preventDefault();
                        simulateAttention();
                        break;
                    case ' ':
                        event.preventDefault();
                        if (autoDemoInterval) {
                            stopAutoDemo();
                        } else {
                            startAutoDemo();
                        }
                        break;
                }
            } catch (error) {
                console.error('Keyboard shortcut error:', error);
            }
        });

        // Memory pattern recognition game
        function startMemoryGame() {
            if (isGameActive) {
                console.log('Game already active');
                return;
            }
            
            console.log('Starting memory game...');
            isGameActive = true;
            
            resetMemory();
            
            // Show a pattern
            const patternLength = 5;
            const pattern = [];
            
            while (pattern.length < patternLength) {
                const index = Math.floor(Math.random() * 200);
                if (!pattern.includes(index)) {
                    pattern.push(index);
                }
            }
            
            console.log('Game pattern:', pattern);
            
            // Display pattern
            pattern.forEach((index, i) => {
                setTimeout(() => {
                    const cell = memoryGrid[index];
                    if (cell) {
                        cell.classList.add('active');
                        setTimeout(() => {
                            cell.classList.remove('active');
                        }, 600);
                    }
                }, i * 800);
            });
            
            // Start recall phase
            setTimeout(() => {
                alert('Now try to click the cells in the same order you saw them light up!');
                let userPattern = [];
                
                const gameClickHandler = function(event) {
                    if (!isGameActive) return;
                    
                    const index = parseInt(this.dataset.index);
                    userPattern.push(index);
                    this.classList.add('active');
                    
                    console.log('User clicked:', index, 'Pattern so far:', userPattern);
                    
                    if (userPattern.length === pattern.length) {
                        isGameActive = false;
                        
                        // Check if correct
                        const correct = userPattern.every((val, i) => val === pattern[i]);
                        
                        setTimeout(() => {
                            if (correct) {
                                alert('Perfect! You have excellent memory! 🎉');
                            } else {
                                alert(`Close, but not quite right. Memory is tricky! 🤔\nCorrect pattern: ${pattern}\nYour pattern: ${userPattern}`);
                            }
                            resetMemory();
                            
                            // Remove event listeners
                            memoryGrid.forEach(cell => {
                                cell.removeEventListener('click', gameClickHandler);
                            });
                        }, 500);
                    }
                };
                
                // Add event listeners for game
                memoryGrid.forEach(cell => {
                    cell.addEventListener('click', gameClickHandler);
                });
                
            }, pattern.length * 800 + 1000);
        } ' ':
                    event.preventDefault();
                    if (autoDemoInterval) {
                        stopAutoDemo();
                    } else {
                        startAutoDemo();
                    }
                    break;
            }
        });

        // Performance monitoring (simulate real metrics)
        function updatePerformanceMetrics() {
            const metrics = {
                'Memory Utilization': Math.random() * 0.3 + 0.6, // 60-90%
                'Attention Coherence': Math.random() * 0.2 + 0.75, // 75-95%
                'Retrieval Accuracy': Math.random() * 0.15 + 0.8, // 80-95%
                'Consolidation Rate': Math.random() * 0.1 + 0.85 // 85-95%
            };
            
            return metrics;
        }

        // Add performance display
        function createPerformanceDisplay() {
            const existingPerf = document.getElementById('performanceSection');
            if (existingPerf) {
                console.log('Performance display already exists');
                return;
            }
            
            const perfSection = document.createElement('div');
            perfSection.className = 'section';
            perfSection.id = 'performanceSection';
            perfSection.innerHTML = `
                <h2>Live Performance Metrics</h2>
                <div class="info-panel">
                    <div id="metricsDisplay"></div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="demo-button" onclick="updateMetricsDisplay()">🔄 Refresh Metrics</button>
                        <button class="demo-button" onclick="startAutoDemo()" style="margin-left: 10px;">▶️ Auto Demo</button>
                        <button class="demo-button" onclick="stopAutoDemo()" style="margin-left: 10px;">⏹️ Stop Auto</button>
                    </div>
                </div>
            `;
            
            // Insert before footer
            const footer = document.querySelector('.footer');
            if (footer && footer.parentNode) {
                footer.parentNode.insertBefore(perfSection, footer);
                console.log('Performance display created');
            }
        }

        function updateMetricsDisplay() {
            const metrics = updatePerformanceMetrics();
            const display = document.getElementById('metricsDisplay');
            
            if (display) {
                display.innerHTML = Object.entries(metrics).map(([name, value]) => `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0; padding: 10px; background: white; border-radius: 8px; transition: all 0.3s ease;">
                        <span><strong>${name}:</strong></span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 200px; height: 10px; background: #e2e8f0; border-radius: 5px; overflow: hidden;">
                                <div style="width: ${value * 100}%; height: 100%; background: linear-gradient(90deg, #38b2ac, #4fd1c7); transition: width 1s ease;"></div>
                            </div>
                            <span style="min-width: 50px; text-align: right; font-weight: 600; color: #2d3748;">${(value * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                `).join('');
                console.log('Metrics updated');
            } else {
                console.error('Metrics display element not found');
            }
        }

        // Add enhanced tooltips and help
        function addTooltips() {
            const elements = [
                { selector: '[onclick="simulateEncoding()"]', text: 'Simulate memory encoding process (Keyboard: 1)' },
                { selector: '[onclick="simulateRetrieval()"]', text: 'Simulate memory retrieval with attention (Keyboard: 2)' },
                { selector: '[onclick="simulateForgetting()"]', text: 'Simulate memory decay and forgetting (Keyboard: 3)' },
                { selector: '[onclick="resetMemory()"]', text: 'Reset all memories to empty state (Keyboard: 4)' },
                { selector: '[onclick="simulateAttention()"]', text: 'Demonstrate attention mechanism (Keyboard: A)' }
            ];
            
            elements.forEach(({ selector, text }) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.title = text;
                    element.setAttribute('aria-label', text);
                }
            });
        }

        // Enhanced initialization with error handling
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Enhanced initialization starting...');
            
            try {
                // Initialize memory grid
                initializeMemoryGrid();
                
                // Add tooltips
                setTimeout(() => {
                    addTooltips();
                }, 500);
                
                // Add game button to demo controls
                setTimeout(() => {
                    const gameButton = document.createElement('button');
                    gameButton.className = 'demo-button';
                    gameButton.textContent = '🎮 Memory Game';
                    gameButton.onclick = startMemoryGame;
                    gameButton.title = 'Test your memory with a pattern recognition game';
                    
                    const controls = document.querySelector('.demo-controls');
                    if (controls) {
                        controls.appendChild(gameButton);
                        console.log('Memory game button added');
                    }
                }, 1000);
                
                // Add help text
                setTimeout(() => {
                    const helpText = document.createElement('p');
                    helpText.style.textAlign = 'center';
                    helpText.style.color = 'rgba(255,255,255,0.8)';
                    helpText.style.marginTop = '20px';
                    helpText.style.fontSize = '0.9em';
                    helpText.innerHTML = `
                        💡 <strong>Keyboard Shortcuts:</strong> 
                        Press <kbd>1</kbd> Encoding | <kbd>2</kbd> Retrieval | <kbd>3</kbd> Forgetting | <kbd>4</kbd> Reset | <kbd>A</kbd> Attention | <kbd>Space</kbd> Auto-demo
                    `;
                    
                    const demoSection = document.querySelector('.interactive-demo');
                    if (demoSection) {
                        demoSection.appendChild(helpText);
                        console.log('Help text added');
                    }
                }, 1500);
                
                // Create performance display
                setTimeout(() => {
                    try {
                        createPerformanceDisplay();
                        updateMetricsDisplay();
                    } catch (error) {
                        console.error('Error creating performance display:', error);
                    }
                }, 2000);
                
                console.log('Enhanced initialization complete!');
                
                // Show welcome message
                setTimeout(() => {
                    if (window.confirm('Welcome to Human MemoryNet! 🧠\n\nWould you like to see a quick demo of the memory simulation?\n\nClick OK to start auto-demo, or Cancel to explore manually.')) {
                        startAutoDemo();
                    }
                }, 2500);
                
            } catch (error) {
                console.error('Initialization error:', error);
                alert('There was an error initializing the visualization. Please refresh the page and try again.');
            }
        });

        // Add window error handler
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            console.error('Error details:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });

        // Add CSS for keyboard shortcuts display
        const keyboardStyle = document.createElement('style');
        keyboardStyle.textContent = `
            kbd {
                background: rgba(255,255,255,0.2);
                border: 1px solid rgba(255,255,255,0.3);
                border-radius: 4px;
                padding: 2px 6px;
                font-family: monospace;
                font-size: 0.9em;
                margin: 0 2px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }
        `;
        document.head.appendChild(keyboardStyle);
    </script>
</body>
</html>width = '0%';
            
            // Randomly activate cells to simulate encoding
            const numCells = Math.floor(Math.random() * 20) + 10;
            const indices = [];
            
            for (let i = 0; i < numCells; i++) {
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * 200);
                } while (indices.includes(randomIndex));
                indices.push(randomIndex);
            }
            
            indices.forEach((index, i) => {
                setTimeout(() => {
                    const cell = cells[index];
                    const memoryType = Math.random() > 0.5 ? 'episodic' : 'semantic';
                    cell.className = `memory-cell ${memoryType}`;
                    
                    // Update progress
                    progressFill.style.width = `${((i + 1) / numCells) * 100}%`;
                }, i * 100);
            });
        }

        // Simulate memory retrieval
        function simulateRetrieval() {
            console.log('Starting retrieval simulation...');
            
            const activeCells = memoryGrid.filter(cell => 
                cell.classList.contains('episodic') || cell.classList.contains('semantic')
            );
            
            if (activeCells.length === 0) {
                alert('No memories to retrieve! Try encoding some memories first by clicking "Simulate Encoding".');
                return;
            }
            
            // Clear any previous active states
            memoryGrid.forEach(cell => {
                cell.classList.remove('active');
            });
            
            // Randomly select cells for retrieval with attention weights
            const retrievalCount = Math.min(8, activeCells.length);
            const selectedCells = [];
            
            // Select unique cells
            while (selectedCells.length < retrievalCount && selectedCells.length < activeCells.length) {
                const randomCell = activeCells[Math.floor(Math.random() * activeCells.length)];
                if (!selectedCells.includes(randomCell)) {
                    selectedCells.push(randomCell);
                }
            }
            
            // Animate retrieval with attention weights
            selectedCells.forEach((cell, i) => {
                setTimeout(() => {
                    cell.classList.add('active');
                    
                    // Create pulsing effect for high attention
                    cell.style.animation = 'pulse 0.8s ease-in-out';
                    
                    setTimeout(() => {
                        cell.classList.remove('active');
                        cell.style.animation = '';
                    }, 1200);
                }, i * 150);
            });
            
            console.log('Retrieval simulation completed for', selectedCells.length, 'memories');
        }

        // Simulate forgetting
        function simulateForgetting() {
            console.log('Starting forgetting simulation...');
            
            const activeCells = memoryGrid.filter(cell => 
                cell.classList.contains('episodic') || cell.classList.contains('semantic')
            );
            
            if (activeCells.length === 0) {
                alert('No memories to forget! Try encoding some memories first.');
                return;
            }
            
            // Episodic memories fade faster than semantic memories
            const episodicCells = activeCells.filter(cell => cell.classList.contains('episodic'));
            const semanticCells = activeCells.filter(cell => cell.classList.contains('semantic'));
            
            // Forget 40% of episodic memories and 20% of semantic memories
            const episodicForgetCount = Math.floor(episodicCells.length * 0.4);
            const semanticForgetCount = Math.floor(semanticCells.length * 0.2);
            
            // Animate forgetting for episodic memories
            for (let i = 0; i < episodicForgetCount; i++) {
                const randomCell = episodicCells[Math.floor(Math.random() * episodicCells.length)];
                setTimeout(() => {
                    if (randomCell) {
                        randomCell.classList.add('fading');
                        setTimeout(() => {
                            randomCell.className = 'memory-cell';
                        }, 2000);
                    }
                }, i * 200);
            }
            
            // Animate forgetting for semantic memories (slower)
            for (let i = 0; i < semanticForgetCount; i++) {
                const randomCell = semanticCells[Math.floor(Math.random() * semanticCells.length)];
                setTimeout(() => {
                    if (randomCell) {
                        randomCell.classList.add('fading');
                        setTimeout(() => {
                            randomCell.className = 'memory-cell';
                        }, 2000);
                    }
                }, (episodicForgetCount * 200) + (i * 300));
            }
            
            console.log('Forgetting simulation: forgetting', episodicForgetCount, 'episodic and', semanticForgetCount, 'semantic memories');
        }

        // Reset memory grid
        function resetMemory() {
            const cells = document.querySelectorAll('.memory-cell');
            const progressFill = document.getElementById('progressFill');
            
            cells.forEach(cell => {
                cell.className = 'memory-cell';
            });
            
            progressFill.style.
